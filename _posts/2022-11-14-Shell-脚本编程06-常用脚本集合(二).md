---
layout: post
title: Shell-脚本编程06-常用脚本集合(二)
date: 2022-11-14
tags: Linux-Shell脚本
music-id: 1824045033
---

### 1. 本地批量向远端机器拷贝文件

```sh
[root@kubesphere ~]# cat ip.txt
192.168.20.5
192.168.20.6
192.168.20.7
192.168.20.8

用法
[root@kubesphere ~]# ./remote-file.sh
请输入要拷贝的文件或目录(注：输入脚本与被拷贝文件或目录的相对路径,并且结尾不要有/)：
```

脚本文件

```sh
#!/bin/bash
#
#****************************************************************************
#Author:                moumou
#QQ:                    xxxxxx
#Date:                  2022-09-21
#FileName：             remote-file.sh
#URL:                   https://blog.linuxtian.top
#Description：          The test script
#Copyright (C):         2021 All rights reserved
#README:                此脚本适用在没有root权限且普通用户具有sudo权限的环境下
#*****************************************************************************
rpm -qa|grep expect

if [ $? == 0 ]

        then

        echo "expect 命令已安装"

        else

        echo "安装 expect 命令"

        yum -y install expect > /dev/null
fi

# 远端主机用户名
user=tianxiang
# 远端主机密码
password="123123"
# 这里需要定义一下普通用户家目录，因为由于文件的权限，只能先拷贝到普通用户家目录下面
userpath="/home/tianxiang"
# 然后再定义最终要将文件放到远端机器的哪个目录下
remotepath="/tmp"

ip_list=ip.txt

if [ ! -f "$ip_list" ];then
        echo "远端主机列表"ip.txt"文件不存在"
        exit 0
else
read -p "请输入要拷贝的文件或目录(注：输入脚本与被拷贝文件或目录的相对路径,并且结尾不要有"/"):" REMOTEPATCH

for id in $(cat $ip_list);do


# 注意: 有些主机ssh远程或者scp的时候，它提示你输入密码的那个提示信息是大写开头的 P "Password"
expect <<EOF
set timeout -1
spawn sudo scp -P 8522 -r $REMOTEPATCH $user@$id:$userpath
expect {
        "yes/no" { send "yes\r"; exp_continue }
        "password" { send "$password\r" }
}
expect eof
EOF

if [ ! -f $userpath/$REMOTEPATCH ];then

	echo -e "\033[31m "$id 文件拷贝失败"\033[0m"

	break

else

fi

expect <<EOF
set timeout -1
spawn sudo ssh -p 8522 $user@$id
expect {
        "yes/no" { send "yes\r"; exp_continue }
        "password" { send "$password\r" }
}

expect "]*" {send "sudo cp $userpath/$REMOTEPATCH $remotepath\r"}
# 这里输入一次密码就行，因为默认5分钟内执行sudo命令不会再提示输入密码
expect "sudo"  { send "$password\r" }
expect "]*"  { send "sudo chown root:root $remotepath/$REMOTEPATCH\r" }
expect "]*" {send "exit\r"}
expect eof
EOF

if [ $? == 0 ];then

	echo -e "\033[36m "已将$REMOTEPATCH"拷贝到"$id"主机中\033[0m"

else

        echo -e "\033[31m "文件拷贝失败"\033[0m"

	break
# 后期只要有想在远程主机操作的命令，只需要继续添加expect <<EOF字段即可
fi
done

fi
```

### 2. 本地批量向远端机器创建指定目录

```sh
[root@kubesphere ~]# cat ip.txt
192.168.20.5
192.168.20.6
192.168.20.7
192.168.20.8

使用方法
[root@kubesphere ~]# ./remote-mkdir.sh
请输入远端主机要创建的目录(注：输入绝对目录路径)：
```

```sh
#!/bin/bash
#
#****************************************************************************
#Author:                moumou
#QQ:                    xxxxxx
#Date:                  2022-09-21
#FileName：             remote-mkdir.sh
#URL:                   https://blog.linuxtian.top
#Description：          The test script
#Copyright (C):         2021 All rights reserved
#README:                此脚本适用在没有root权限且普通用户具有sudo权限的环境下
#*****************************************************************************
rpm -qa|grep expect

if [ $? == 0 ]

        then

        echo "expect 命令已安装"

        else

        echo "安装 expect 命令"

        yum -y install expect > /dev/null
fi

user=tianxiang
password="123123" #所有主机密码相同
ip_list=ip.txt

if [ ! -f "$ip_list" ];then
        echo "远端主机列表"ip.txt"文件不存在"
        exit 0
else
read -p "请输入远端主机要创建的目录(注：输入绝对目录路径):" REMOTEPATCH

for id in $(cat $ip_list);do

# 注意: 有些主机ssh远程或者scp的时候，它提示你输入密码的那个提示信息是大写开头的 P "Password"
expect <<EOF
set timeout 20
spawn sudo ssh $user@$id
expect {
        "yes/no" { send "yes\r"; exp_continue }
        "password" { send "$password\r" }
}

expect "]*" {send "sudo mkdir -pv $REMOTEPATCH\r"}
expect "sudo"  { send "$password\r" }
expect "]*"  { send "sudo chown root:root $REMOTEPATCH\r" }
expect "]*" {send "exit\r"}
expect eof
EOF
done
echo -e "\033[36m ---------------------------\033[0m"
echo -e "\033[36m 已在主机"$id"中创建'$REMOTEPATCH'目录\033[0m"
fi
```

### 3. 批量修改 k8s 节点 kubelet 工作目录

```sh
#!/bin/bash
#
#****************************************************************************
#Author:                moumou
#QQ:                    xxxxxx
#Date:                  2022-09-21
#FileName：             remote-mkdir.sh
#URL:                   https://blog.linuxtian.top
#Description：          The test script
#Copyright (C):         2021 All rights reserved
#README:                此脚本适用在没有root权限且普通用户具有sudo权限的环境下
#*****************************************************************************
rpm -qa|grep expect

if [ $? == 0 ]

        then

        echo "expect 命令已安装"

        else

        echo "安装 expect 命令"

        yum -y install expect > /dev/null
fi

user=rongqiyun
# 远端主机密码
password="1qazZAQ@"
# 这里需要定义一下普通用户家目录，因为由于文件的权限，只能先拷贝到普通用户家目录下面
userpath="/home/rongqiyun"
# 然后再定义最终要将文件放到远端机器的哪个目录下
remotepath="/etc/systemd/system/kubelet.service.d"

ip_list=caas-03-b14.txt

if [ ! -f "$ip_list" ];then
        echo "远端主机列表"$ip_list"文件不存在"
        exit 0
else
read -p "请输入要拷贝的文件或目录(注：输入脚本与被拷贝文件或目录的相对路径,并且结尾不要有"/"):" REMOTEPATCH

for id in $(cat $ip_list);do


# 注意: 有些主机ssh远程或者scp的时候，它提示你输入密码的那个提示信息是大写开头的 P "Password"

# 1. 将事先本地准备好的文件拷贝到远端主机的普通用户目录下
expect <<EOF
set timeout 20
spawn sudo scp -P 5151 -r $REMOTEPATCH $user@$id:$userpath
expect {
        "yes/no" { send "yes\r"; exp_continue }
        "Password" { send "$password\r" }
}
expect eof
EOF

# 2. 登录到远程机器上，停止kubelet和备份10-kubeadm.conf文件
expect <<EOF
set timeout 20
spawn sudo ssh -p 5151 $user@$id
expect {
        "yes/no" { send "yes\r"; exp_continue }
        "Password" { send "$password\r" }
}

expect "]*" {send "sudo systemctl stop kubelet\r" }
expect "sudo"  { send "$password\r" }
expect "]*" { send "sudo cp /etc/systemd/system/kubelet.service.d/10-kubeadm.conf /etc/systemd/system/kubelet.service.d/10-kubeadm.conf.bak\r" }
expect "]*" { send "sudo ls /etc/systemd/system/kubelet.service.d/\r" }
expect "]*" { send "exit\r" }
expect eof
EOF

# 3. 然后将普通用户的家目录下的文件移动到指定目录下并修改属主和属组，最后启动kubelet
expect <<EOF
set timeout 20
spawn sudo ssh -p 5151 $user@$id
expect {
        "yes/no" { send "yes\r"; exp_continue }
        "Password" { send "$password\r" }
}

expect "]*" {send "sudo \mv $userpath/$REMOTEPATCH $remotepath\r"}
expect "sudo"  { send "$password\r" }
expect "]*" { send "sudo chown root:root $remotepath/$REMOTEPATCH\r" }
expect "]*" { send "sudo systemctl daemon-reload\r" }
expect "]*" { send "sudo systemctl start kubelet\r" }
expect "]*" {send "exit\r"}
expect eof
EOF

# 后期只要有想在远程主机操作的命令，只需要继续添加expect <<EOF字段即可
echo -e "\033[36m "已将$REMOTEPATCH"拷贝到"$id"主机中并修改kubelet存储目录\033[0m"
done
fi
```

### 4. 获取harbor仓库镜像列表，并以文本输出

此脚本中运用到 for 循环和 awk 输出

```sh
[root@VM-16-9-centos syncharbor]# vim search-harbor.sh
#!/bin/bash
#
#****************************************************************************
#Author:                甄天祥
#QQ:                    2099637909
#Date:                  2022-09-21
#URL:                   https://blog.linuxtian.top
#Description：          查询harbor仓库所有镜像列表
#Copyright (C):         2021 All rights reserved
#README:                xxxxxxxxxxxx
#HarborAPI              2.0
#*****************************************************************************

Harbor_User=admin                                       # Harbor的用户
Harbor_Passwd=Harbor12345                               # Harbor的密码
Harbor_Address=10.0.16.9:1443                       # Harbor地址
Images_List_File=`pwd`/harbor-list-images-`date '+%Y-%m-%d-%H-%M'`.txt       # Harbor仓库所有镜像列表
# 获取远端镜像仓库项目列表
Project_List=$(curl -s -k -u "$Harbor_User:$Harbor_Passwd" -X GET "https://$Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')

for Project in $Project_List;do
   # 循环获取远端项目下所有的镜像
    Image_Names=$(curl -s -k -u "$Harbor_User:$Harbor_Passwd" -X GET "https://$Harbor_Address/api/v2.0/projects/$Project/repositories?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')
    for Image in $Image_Names;do
        # 循环获取远端镜像的版本(tag)
        Image_Tags=$(curl -s -k -u "$Harbor_User:$Harbor_Passwd" -X GET  "https://$Harbor_Address/v2/$Image/tags/list?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |python -m json.tool | awk -F '"' '{print $2}'|egrep -v "name|tags"|sed '/^$/d') # 使用tail -n 3 ，就是截取每条镜像最近的3个tag，tag的规律性是这样取值的前提性，如:2022112501，不然无法取到准确的值
        for Tag in $Image_Tags;do
            # 格式化输出远端镜像信息
            echo "$Image":"$Tag"   >> $Images_List_File
        done
    done
done
```

### 5. 将其他镜像仓库的镜像同步到本地仓库

此脚本中运用到 for 循环和 wak 输出 以及 grep 过滤

> 注意：镜像仓库同步前，本地仓库至少有一个镜像，并且两个镜像仓库之间可以互相 login

最后用计划任务定时执行脚本以及清理日志即可

```sh
[root@kubesphere ~]# crontab -e
# 每5分钟执行镜像同步脚本
*/5 * * * * sh /sync-harbor-v1.sh
# 每天删除1天前的日志文件，也就是今天删除昨天的
* * */1 * *find /var/log/sync-harbor-* -mtime +1 -type f  -exec rm -rf {} \;
```

#### 1. 远端镜像仓库所有镜像同步过来

```sh
[root@kubesphere ~]# cat sync-harbor-v1.sh
#!/bin/bash
#
#****************************************************************************
#Author:                甄天祥
#QQ:                    2099637909
#Date:                  2022-09-21
#URL:                   https://blog.linuxtian.top
#Description：          无条件同步远端harbor仓库到本地harbor仓库
#Copyright (C):         2021 All rights reserved
#README:                xxxxxxxxxxxx
#HarborAPI              2.0
#*****************************************************************************

Source_Harbor_User=admin                                       # 远端登录Harbor的用户
Source_Harbor_Passwd=Harbor12345                               # 远端登录Harbor的用户密码
Source_Harbor_Address=192.168.110.11:1443                       # 远端登录地址
Local_Harbor_User=admin                                       # 本端登录Harbor的用户
Local_Harbor_Passwd=Harbor12345                              # 本端登录Harbor的用户密码
Local_Harbor_Address=192.168.110.12:1443                      # 本端登录地址
Images_List_File=`pwd`/source_harbor-list-images-`date '+%Y-%m-%d-%H-%M'`.txt       # 远端harbor仓库所有镜像列表
error_image_file=`pwd`/error_image_file-`date '+%Y-%m-%d-%H-%M'`.txt     # 报错镜像集合
exec > /var/log/sync-harbor-v1-`date '+%Y-%m-%d-%H-%M'`.log 2>&1   # 标准正确输出和错误输出到log日志

# 获取远端镜像仓库项目列表
Source_Project_List=$(curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')

# 本端镜像仓库创建远端所有的项目列表
for Create_Project in $Source_Project_List;do

   value=`curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET "https://$Local_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`

 if [[ `echo "$value"|grep "$Create_Project"` == "$Create_Project" ]]

   then

        echo -e "\033[36;4m $Create_Project 项目已存在!\033[0m"

   else
        curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X POST "https://$Local_Harbor_Address/api/v2.0/projects" -H "Content-Type:application/json" -d '{"project_name": "'$Create_Project'", "metadata": {"public": "false"}, "storage_limit": -1}'

        if [ $? != 0 ]

        then

            echo -e "\033[31;4m $Create_Project 项目创建失败!\033[0m"

            exit 0

        else

            echo -e "\033[36;4m $Create_Project 项目创建成功!\033[0m"
        fi

  fi

done


for Project in $Source_Project_List;do
   # 循环获取远端项目下所有的镜像
    Source_Image_Names=$(curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects/$Project/repositories?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')
    for Source_Image in $Source_Image_Names;do
        # 循环获取远端镜像的版本(tag)
        Source_Image_Tags=$(curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET  "https://$Source_Harbor_Address/v2/$Source_Image/tags/list?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |python -m json.tool | awk -F '"' '{print $2}'|egrep -v "name|tags"|sed '/^$/d') # 使用tail -n 3 ，就是截取每条镜像最近的3个tag，tag的规律性是这样取值的前提性，如:2022112501，不然无法取到准确的值
        for Source_Tag in $Source_Image_Tags;do
            # 格式化输出远端镜像信息
            echo "$Source_Image":"$Source_Tag"   >> $Images_List_File
        done
    done
done


# 推送镜像到本地仓库，并删除无用镜像以做到释放空间压力

docker login $Source_Harbor_Address -u $Source_Harbor_User -p $Source_Harbor_Passwd
docker login $Local_Harbor_Address -u $Local_Harbor_User -p $Local_Harbor_Passwd

if [ $? == 0 ]

then

        echo -e "\033[36;4m 仓库login成功,进行拉取并推送镜像!\033[0m"

else

        echo -e "\033[31;4m 仓库login失败,请检查授权!\033[0m"

        exit 0

fi

for image_file in `cat $Images_List_File`;do

docker pull `echo "$Source_Harbor_Address"/"$image_file"`

if [ $? == 0 ]

then

        echo -e "\033[36;4m $image 镜像拉取成功!开始推送镜像至仓库\033[0m"


        docker tag $Source_Harbor_Address/$image_file $Local_Harbor_Address/$image_file

        if [ $? == 0 ]

        then
            docker push $Local_Harbor_Address/$image_file
            wait
            docker rmi $Local_Harbor_Address/$image_file
            docker rmi $Source_Harbor_Address/$image_file

        else

            echo -e "\033[31;4m "$Local_Harbor_Address/$image_file"推送失败\033[0m"

            exit 0

        fi
else

        echo -e "$image_file 镜像拉取失败!" >> $error_image_file
fi

done
echo -e "\033[36m -------------------------镜像同步完成!------------------------- \033[0m"
```

#### 2. 对比两个仓库拉取本地仓库没有的镜像

```sh
[root@kubesphere ~]# cat sync-harbor-v2.sh
#!/bin/bash
#
#****************************************************************************
#Author:                甄天祥
#QQ:                    2099637909
#Date:                  2022-09-21
#URL:                   https://blog.linuxtian.top
#Description：          只同步本地harbor仓库中没有远端harbor仓库中的镜像
#Copyright (C):         2021 All rights reserved
#README:                xxxxxxxxxxxx
#HarborAPI              2.0
#*****************************************************************************

Source_Harbor_User=admin                                       # 远端登录Harbor的用户
Source_Harbor_Passwd=Harbor12345                              # 远端登录Harbor的用户密码
Source_Harbor_Address=k8s.harbor.com:443                           # 远端登录地址
Source_Images_List_File=`pwd`/source_harbor-list-images-`date '+%Y-%m-%d-%H-%M'`.txt       # 远端harbor仓库所有镜像列表
Local_Harbor_User=admin                                       # 本端登录Harbor的用户
Local_Harbor_Passwd=Harbor12345                              # 本端登录Harbor的用户密码
Local_Harbor_Address=192.168.20.120:1443                           # 本端登录地址
Local_Images_List_File=`pwd`/local_harbor-list-images-`date '+%Y-%m-%d-%H-%M'`.txt        # 本端harbor仓库所有镜像列表
New_Images_List=`pwd`/New_Images_List-`date '+%Y-%m-%d-%H-%M'`.txt     # 新获取镜像列表
error_image_file=`pwd`/error_image_file-`date '+%Y-%m-%d-%H-%M'`.txt     # 报错镜像集合
exec > /var/log/sync-harbor-v2-`date '+%Y-%m-%d-%H-%M'`.log 2>&1   # 标准正确输出和错误输出到log日志

# 获取远端镜像仓库镜像列表
Source_Project_List=`curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`

for Source_Project in $Source_Project_List;do
   # 循环获取远端项目下所有的镜像
    Source_Image_Names=$(curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects/$Source_Project/repositories?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')
    for Source_Image in $Source_Image_Names;do
        # 循环获取远端镜像的版本(tag)
        Source_Image_Tags=$(curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET  "https://$Source_Harbor_Address/v2/$Source_Image/tags/list?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |python -m json.tool | awk -F '"' '{print $2}'|egrep -v "name|tags"|sed '/^$/d') # 使用tail -n 3 ，就是截取每条镜像最近的3个tag，tag的规律性是这样取值的前提性，如:2022112501，不然无法取到准确的值
        for Source_Tag in $Source_Image_Tags;do
            # 格式化输出远端镜像信息
            echo "$Source_Image:$Source_Tag"   >> $Source_Images_List_File
        done
    done
done

# 本端镜像仓库创建远端所有的项目列表
for Create_Project in $Source_Project_List;do

   value=`curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET "https://$Local_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`

 if [[ `echo "$value"|grep "$Create_Project"` == "$Create_Project" ]]

   then

        echo -e "\033[36;4m $Create_Project 项目已存在!\033[0m"

   else
        curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X POST "https://$Local_Harbor_Address/api/v2.0/projects" -H "Content-Type:application/json" -d '{"project_name": "'$Create_Project'", "metadata": {"public": "false"}, "storage_limit": -1}'

        if [ $? != 0 ]

        then

            echo -e "\033[31;4m $Create_Project 项目创建失败!\033[0m"

            exit 0

        else

            echo -e "\033[36;4m $Create_Project 项目创建成功!\033[0m"
        fi

  fi

done


# 获取本端镜像仓库镜像列表
Local_Project_List=$(curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET "https://$Local_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')

for Local_Project in $Local_Project_List;do
   # 循环获取本端项目下所有的镜像
    Local_Image_Names=$(curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET "https://$Local_Harbor_Address/api/v2.0/projects/$Local_Project/repositories?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')
    for Local_Image in $Local_Image_Names;do
        # 循环获取本端镜像的版本（tag)
        Local_Image_Tags=$(curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET  "https://$Local_Harbor_Address/v2/$Local_Image/tags/list?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |python -m json.tool | awk -F '"' '{print $2}'|egrep -v "name|tags"|sed '/^$/d') # 如果本地仓库要同步远端仓库的镜像，则本地仓库无需像上面的一样使用tail截取最近的3个tag
        for Local_Tag in $Local_Image_Tags;do
            # 格式化输出本端镜像信息
            echo "$Local_Image:$Local_Tag"   >> $Local_Images_List_File
        done
    done
done

# 比对两个镜像列表
cat $Source_Images_List_File |grep -vFx --file $Local_Images_List_File  > /dev/null

if [ $? == 1 ]


    then
        echo -e "\033[36m 远端镜像仓库信息无变动，本地无需同步新镜象 \033[0m"

        exit 0

        else

        echo -e "\033[36m 远端镜像仓库信息有变动，本地需要同步新镜像 \033[0m"

        Diff_Images=`cat $Source_Images_List_File |grep -vFx --file $Local_Images_List_File`

for New_Images in $Diff_Images;do

    # 循环将远端新镜像输出到本地
    echo "$New_Images" >>$New_Images_List
done

fi

# 推送镜像到本地仓库，并删除无用镜像以做到释放空间压力

docker login $Source_Harbor_Address -u $Source_Harbor_User -p $Source_Harbor_Passwd
docker login $Local_Harbor_Address -u $Local_Harbor_User -p $Local_Harbor_Passwd

if [ $? == 0 ]

then

        echo -e "\033[36;4m 仓库login成功,进行拉取并推送镜像!\033[0m"

else

        echo -e "\033[31;4m 仓库login失败,请检查授权!\033[0m"

        exit 0

fi

for image_file in `cat $New_Images_List`;do

docker pull `echo "$Source_Harbor_Address"/"$image_file"`

if [ $? == 0 ]

then

        echo -e "\033[36;4m $image 镜像拉取成功!开始推送镜像至仓库\033[0m"


        docker tag $Source_Harbor_Address/$image_file $Local_Harbor_Address/$image_file

        if [ $? == 0 ]

        then
            docker push $Local_Harbor_Address/$image_file
            wait
            docker rmi $Local_Harbor_Address/$image_file
            docker rmi $Source_Harbor_Address/$image_file

        else

            echo -e "\033[31;4m "$Local_Harbor_Address/$image_file"推送失败\033[0m"

            exit 0

        fi
else

        echo -e "$image_file 镜像拉取失败!" >> $error_image_file
fi

done
echo -e "\033[36m -------------------------镜像同步完成!------------------------- \033[0m"
```

#### 3. 查找远端仓库3天内推送过的镜像并拉取到本地然后推送到本地harbor仓库

```sh
[root@kubesphere ~]# cat sync-harbor-v3.sh
#!/bin/bash
#
#****************************************************************************
#Author:                甄天祥
#QQ:                    2099637909
#Date:                  2022-10-16
#URL:                   https://blog.linuxtian.top
#Description：          同步远端harbor仓库中3天内推送过的镜像到本地仓库
#Copyright (C):         2021 All rights reserved
#README:                xxxxxxxxxxxx
#HarborAPI              2.0
#*****************************************************************************
Source_Harbor_User=admin                                       # 远端Harbor的用户
Source_Harbor_Passwd=Harbor12345                               # 远端Harbor的密码
Source_Harbor_Address=10.0.16.9:1443                       # 远端Harbor地址
Local_Harbor_User=admin                                       # 本地Harbor的用户
Local_Harbor_Passwd=Harbor12345                               # 本地Harbor的密码
Local_Harbor_Address=10.0.16.9:30143                       # 本地Harbor地址
Source_Images_List_File=`pwd`/Source_Images_List_File-`date '+%Y-%m-%d-%H-%M'`.txt       # 远端Harbor仓库3天内变更的tags列表
Local_Images_List_File=`pwd`/Local_Images_List_File-`date '+%Y-%m-%d-%H-%M'`.txt         # 本地Harbor仓库3天内变更的tags列表
three_days_time=`date --date="72 hours ago" +"%Y%m%d"`     # 3天前时间变量
error_image_file=`pwd`/error_image_file-`date '+%Y-%m-%d-%H-%M'`.txt     # 报错镜像集合
Three_days_New_Images_List=`pwd`/Three_days_New_Images_List-`date '+%Y-%m-%d-%H-%M'`.txt  # 筛选出来的3天内的镜像
exec > /var/log/sync-harbor-v3-`date '+%Y-%m-%d-%H-%M'`.log 2>&1   # 标准正确输出和错误输出到log日志



# 获取远端镜像仓库项目列表
Source_Project_List=$(curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}')

# 获取远端所有镜像库和时间戳
for Source_Project in $Source_Project_List;do

# 定义最近3天变动过的镜像,此命令只是获取到镜像的名字和时间戳如:library/busybox 2022-10-14
Source_image_list_name_and_uptime=`curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects/$Source_Project/repositories?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |python -m json.tool  |grep -E "update_time|name" |awk -F '"' '{print $4}' |sed 'N;s/\n/:/' |awk -F ':' '{print $1":"$2}' |sed 's/...$//'`


# 获取远端3天内所有镜像镜像项目、镜像仓库、镜像变动时间


for Source_change_image_library_name_uptime in $Source_image_list_name_and_uptime;do

Source_image_library_name=`echo $Source_change_image_library_name_uptime |awk -F ":" '{print $1}'`

Source_image_library_uptime=`echo $Source_change_image_library_name_uptime |awk -F ":" '{print $2}'|sed  's/-//g'`

Source_change_project_name=`echo $Source_change_image_library_name_uptime |awk -F ":" '{print $1}'|awk -F "/" '{print $1}'`

Source_change_library_name=`echo $Source_change_image_library_name_uptime |awk -F ":" '{print $1}'|awk -F "/" '{print $2}'`


# 判断是否有3天内的镜像仓库

if [[ "$Source_image_library_uptime" -ge "$three_days_time" ]]


    then

        # 获取到3天内发生或变动的镜像tags,此命令获取到镜像的tag和时间戳如:2022-10-14:latest
        Source_Image_Tags_and_Time=`curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET  "https://$Source_Harbor_Address/api/v2.0/projects/$Source_change_project_name/repositories/$Source_change_library_name/artifacts?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |python -m json.tool|grep -E ""\"name\""| "\"push_time\""" |grep -A 1 "name" |awk -F ":" '{print $2}'|awk -F '"' '{print $2}' |sed '/^$/d'|sed 's/T..$//'|sed 'N;s/\n/:/'`

        for Source_Image_Tags in $Source_Image_Tags_and_Time;do
            # 获取到tag的时间戳
            Source_Push_Image_Tags_Time=`echo $Source_Image_Tags |awk -F ":" '{print $2}'|sed  's/-//g'`
            # 获取到镜像tag名称
            Source_Push_Image_Tags_name=`echo $Source_Image_Tags |awk -F ":" '{print $1}'`


            #判断是否有3天内变动过的镜像tags
            if [[ "$Source_Push_Image_Tags_Time" -ge "$three_days_time" ]]

                then
                    # 输出镜像3天内变动过的镜镜像
                    echo $Source_image_library_name":"$Source_Push_Image_Tags_name >>$Source_Images_List_File

                 else

                    echo "$Source_image_library_name:$Source_Push_Image_Tags_name 该镜像tag3天内无变更操作"

            fi

        done

    else
        echo "$Source_image_library_name 该镜像仓库3天内无变更操作"

fi

        done

done

ls $Source_Images_List_File > /dev/null

if [ $? == 0 ]

        then

        echo -e "\033[36;4m 获取到远端Harbor镜像列表!\033[0m"

        else

        echo -e "\033[31;4m 未获取到本地Harbor镜像列表,请检查仓库是否存有≥1个镜像!\033[0m"

    exit 0

fi


# 本地Habror仓库获取远端Harbor仓库所有项目并创建该项目
Local_Project_List=`curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`


# 本端镜像仓库创建远端所有的项目列表
for Local_Create_Project in $Local_Project_List;do

   value=`curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET "https://$Local_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`

 if [[ `echo "$value"|grep "$Local_Create_Project"` == "$Local_Create_Project" ]]

   then

        echo -e "\033[36;4m $Local_Create_Project 项目已存在!\033[0m"

   else
        curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X POST "https://$Local_Harbor_Address/api/v2.0/projects" -H "Content-Type:application/json" -d '{"project_name": "'$Local_Create_Project'", "metadata": {"public": "false"}, "storage_limit": -1}'

        if [ $? != 0 ]

        then

            echo -e "\033[31;4m $Local_Create_Project 项目创建失败!\033[0m"

            exit 0

        else

            echo -e "\033[36;4m $Local_Create_Project 项目创建成功!\033[0m"
        fi

  fi

done

# 获取本端镜像仓库全部的镜像列表，因为要以本端的镜像为基准，拉取远端的3天的内的镜像，所以要获取本端全部的镜像
Local_Project_List=`curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET "https://$Local_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`

for Local_Project in $Local_Project_List;do
   # 循环获取本端项目下所有的镜像
    Local_Image_Names=`curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET "https://$Local_Harbor_Address/api/v2.0/projects/$Local_Project/repositories?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`
    for Local_Image in $Local_Image_Names;do
        # 循环获取本端镜像的版本（tag)
        Local_Image_Tags=`curl -s -k -u "$Local_Harbor_User:$Local_Harbor_Passwd" -X GET  "https://$Local_Harbor_Address/v2/$Local_Image/tags/list?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |python -m json.tool | awk -F '"' '{print $2}'|egrep -v "name|tags"|sed '/^$/d'`
        for Local_Tag in $Local_Image_Tags;do
            # 格式化输出本端镜像信息
            echo "$Local_Image:$Local_Tag"   >> $Local_Images_List_File
        done
    done
done

ls $Local_Images_List_File > /dev/null

if [ $? == 0 ]

    then

    echo -e "\033[36;4m 获取到本地Harbor镜像列表!\033[0m"

    else

    echo -e "\033[31;4m 未获取到本地Harbor镜像列表,请检查仓库是否存有≥1个镜像!\033[0m"

    exit 0

fi

###############################比对两个镜像列表#############################
cat $Source_Images_List_File |grep -vFx --file $Local_Images_List_File  > /dev/null

if [ $? == 1 ]


    then
        echo -e "\033[36;4m 远端镜像仓库信息无变动，本地无需同步新镜象 \033[0m"

        exit 0

        else

        echo -e "\033[36;4m 远端镜像仓库信息有变动，本地需要同步新镜象\033[0m"

        Three_days_Diff_Images=`cat $Source_Images_List_File |grep -vFx --file $Local_Images_List_File`

for Three_days_New_Images in $Three_days_Diff_Images;do

    # 循环将远端新镜像输出到本地
    echo "$Three_days_New_Images" >> $Three_days_New_Images_List
done

fi


# 推送镜像到本地仓库，并删除无用镜像以做到释放空间压力

docker login $Source_Harbor_Address -u $Source_Harbor_User -p $Source_Harbor_Passwd
docker login $Local_Harbor_Address -u $Local_Harbor_User -p $Local_Harbor_Passwd

if [ $? == 0 ]

then

        echo -e "\033[36;4m 仓库login成功,进行拉取并推送镜像!\033[0m"

else

        echo -e "\033[31;4m 仓库login失败,请检查授权!\033[0m"

        exit 0

fi

for image_file in `cat $Three_days_New_Images_List`;do

docker pull `echo "$Source_Harbor_Address"/"$image_file"`

if [ $? == 0 ]

then

        echo -e "\033[36;4m $image 镜像拉取成功!开始推送镜像至仓库\033[0m"


        docker tag $Source_Harbor_Address/$image_file $Local_Harbor_Address/$image_file

        if [ $? == 0 ]

        then
            docker push $Local_Harbor_Address/$image_file
            wait
            docker rmi $Local_Harbor_Address/$image_file
            docker rmi $Source_Harbor_Address/$image_file

        else

            echo -e "\033[31;4m "$Local_Harbor_Address/$image_file"推送失败\033[0m"

            exit 0

        fi
else

        echo -e "$image_file 镜像拉取失败!" >> $error_image_file
fi

done
echo -e "\033[36m -------------------------镜像同步完成!------------------------- \033[0m"
```

#### 4. 实时同步镜像仓库

```sh
#!/bin/bash

# 首先使用查询harbor镜像列表将要同步的仓库中的镜像列表筛选出来到 push-image-list.txt 文件中

Source_Harbor_Address=10.0.16.9:1443          # 被同步仓库
Source_Harbor_User=admin
Source_Harbor_Passwd=Harbor12345
Dest_Harbor_Address=10.0.16.9:30143           # 同步仓库
Dest_Harbor_User=admin
Dest_Harbor_Passwd=Harbor12345
image_list_all='/usr/share/harbor/image-list.txt'
push_image_list='/usr/share/harbor/push-image-list.txt'
filesystem_layer_image='/usr/share/harbor/filesystem_layer_image.txt'

function create_project(){
# 获取远端镜像仓库项目列表,# harbor api 版本 v1
#Source_Project_List=`curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`
# 获取远端镜像仓库项目列表,# harbor api 版本 v2
Source_Project_List=`curl -s -k -u "$Source_Harbor_User:$Source_Harbor_Passwd" -X GET "https://$Source_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`

# 本端镜像仓库创建远端所有的项目列表,# harbor api 版本 v2
for Create_Project in $Source_Project_List;do

   value=`curl -s -k -u "$Dest_Harbor_User:$Dest_Harbor_Passwd" -X GET "https://$Dest_Harbor_Address/api/v2.0/projects?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false"  | python -m json.tool | grep name | awk '/"name": /' | awk -F '"' '{print $4}'`

 if [[ `echo "$value"|grep "$Create_Project"` == "$Create_Project" ]]

   then

        echo -e "\033[33m $Create_Project 项目已存在!\033[0m"

   else
        curl -s -k -u "$Dest_Harbor_User:$Dest_Harbor_Passwd" -X POST "https://$Dest_Harbor_Address/api/v2.0/projects" -H "Content-Type:application/json" -d '{"project_name": "'$Create_Project'", "metadata": {"public": "false"}, "storage_limit": -1}'

        if [ $? != 0 ]

        then

            echo -e "\033[31m $Create_Project 项目创建失败!\033[0m"

            exit 0

        else

            echo -e "\033[32m $Create_Project 项目创建成功!\033[0m"
        fi

  fi

done
}

docker login $Source_Harbor_Address -u $Source_Harbor_User -p $Source_Harbor_Passwd
docker login $Dest_Harbor_Address -u $Dest_Harbor_User -p $Dest_Harbor_Passwd

if [ $? == 0 ] ;then

        echo -e "\033[32m仓库login成功,进行拉取并推送镜像!\033[0m"

else

        echo -e "\033[31m仓库login失败,请检查授权!\033[0m"

        exit 0

fi

while true ;do

     # cat /var/log/harbor/core.log |grep "PUSH_ARTIFACT" |tail -n 40 |grep -Po "(?<=Repository-)[a-zA-Z0-9]{1,}\/[a-zA-Z0-9-]{1,}(?= Tags)|(?<=Tags-\[)[a-zA-Z0-9]{1,}(?=\])"|sed 'N;s/\n/:/'|sort -u

     image_name=$(cat /var/log/harbor/core.log |grep "PUSH_ARTIFACT" |tail -n 40 |grep -Po "(?<=Repository-)[a-zA-Z0-9]{1,}\/[a-zA-Z0-9]{1,}(?= Tags)|(?<=Tags-\[)[a-zA-Z0-9-]{1,}(?=\])"|sed 'N;s/\n/:/'|sort -u)

     echo $image_name |sed 's/ /\n/g' > $image_list_all

     #touch $push_image_list

     diff_image=`cat $image_list_all |grep -vFx --file $push_image_list`

    if [ $? == 0 ] ;then

     echo "$diff_image"  >> $push_image_list

     for image in $diff_image ;do

     docker pull $Source_Harbor_Address/$image

     if [[ $? == 0 ]] ;then

        echo -e "\033[36m$Source_Harbor_Address/$image 镜像拉取成功\033[0m"

        else

        journalctl -xeu docker -n 5|grep filesystem

        if [[ $? == 0 ]] ;then

        echo -e "\033[31m$Source_Harbor_Address/$image 镜像拉取失败,filesystem layer verification failed\033[0m"

        echo "$Source_Harbor_Address/$image" >> $filesystem_layer_image

        fi

     fi

     wait

     docker tag $Source_Harbor_Address/$image $Dest_Harbor_Address/$image

     docker push $Dest_Harbor_Address/$image

        if [[ $? == 0 ]] ;then

            echo -e "\033[36m$Dest_Harbor_Address/$image 推送成功\033[0m"

            else

                journalctl -xeu docker |grep "project .* not found"

                if [[ $? == 0 ]] ;then

                    create_project

                    docker push $Dest_Harbor_Address/$image

                    wait

                    echo -e "\033[36m$Dest_Harbor_Address/$image 推送成功\033[0m"

                    else

                    echo -e "\033[31m$Dest_Harbor_Address/$image 推送失败\033[0m"
                fi
        fi

     wait

     docker rmi $Dest_Harbor_Address/$image

     docker rmi $Source_Harbor_Address/$image

     done

     else

     echo -e "\033[33m没有新镜像推送\033[0m"

     fi

sleep 3

done
```

**systemd 管理脚本**

```sh
[root@VM-16-9-centos ~]# vim /etc/systemd/system/sync-harbor.service
[Unit]
Description = unit file
[Service]
Type = simple
ExecStart = /bin/bash /usr/share/harbor/sync-harbor.sh
[Install]
WantedBy = multi-user.target
[root@VM-16-9-centos ~]# systemctl enable sync-harbor.service --now
[root@VM-16-9-centos ~]# journalctl -xefu sync-harbor
```

### 6. 删除harbor仓库镜像

#### 1. 删除指定镜像

此脚本中运用到 for 循环和 grep 过滤

> 注意：配合主题12的内容进行使用，首先需要获取镜像列表，然后挑出要删除的镜像

```sh
# 首先验证本地镜像列表
[root@master deleharbor]# cat source_harbor-list-images-2022-09-27-16-04.txt
calico/node:v3.22.0
calico/pod2daemon-flexvol:v3.22.0
calico/cni:v3.22.0
calico/kube-controllers:v3.22.0
crunchydata/postgres-operator-upgrade:ubi8-5.1.2-0
crunchydata/postgres-operator:ubi8-5.1.2-0
crunchydata/crunchy-pgbouncer:ubi8-1.16-4
crunchydata/crunchy-postgres:ubi8-14.4-0
crunchydata/crunchy-pgbackrest:ubi8-2.38-2
.........................
```

```sh
[root@master deleharbor]# cat del-harbor-images-v1.sh
#!/bin/bash
harbor_ip=192.168.110.11:1443
harbor_user=admin
harbor_passwd=Harbor12345
deletimage=source_harbor-list-images-2022-09-27-16-04.txt
exec > /var/log/del-harbor-images-info-`date '+%Y-%m-%d-%H-%M'`.log 2>&1   # 标准正确输出和错误输出到log日志

for  delet_all_name in `cat $deletimage`;do
    #定义要删除镜像的项目、仓库及tags变量
        projects_name=`echo $delet_all_name|awk -F "/" '{print $1}'`
        image_name=`echo $delet_all_name|awk -F "/" '{print $2}'|awk -F ":" '{print $1}'`
        tags_name=`echo $delet_all_name|awk -F "/" '{print $2}'|awk -F ":" '{print $2}'`

    #查找要删除镜像的仓库sha256值
    for digest_list in `curl -s -k -u $harbor_user:$harbor_passwd -X GET "https://$harbor_ip/api/v2.0/projects/$projects_name/repositories/$image_name/artifacts?page=1&page_size=100&with_tag=true&with_label=false&with_scan_overview=false&with_signature=false&with_immutable_status=false" |grep "digest" | grep -Po '(?<="digest":")sha256:[a-zA-Z0-9]{10,}(?=")'`
        do

        #删除项目中仓库对应sha256下的tags镜像
            #curl -s -k -u $harbor_user:$harbor_passwd -X DELETE https://$harbor_ip/api/v2.0/projects/$projects_name/repositories/$image_name/artifacts/$digest_list/tags/$tags_name | grep "NOT_FOUND" > /dev/null
            curl -s -k -u $harbor_user:$harbor_passwd -X GET https://$harbor_ip/api/v2.0/projects/$projects_name/repositories/$image_name/artifacts/$digest_list/tags/ |grep "$tags_name" > /dev/null

            if [ $? == 0 ]
                then
                    curl -s -k -u $harbor_user:$harbor_passwd -X DELETE https://$harbor_ip/api/v2.0/projects/$projects_name/repositories/$image_name/artifacts/$digest_list/tags/$tags_name
                    echo -e "\033[36;4m 已将$projects_name/$image_name:$tags_name 镜像删除!\033[0m"
            else
                    echo "$projects_name/$image_name:$tags_name 镜像删除失败，请确认该镜像是否存在！"
        fi
           curl -s -k -u $harbor_user:$harbor_passwd  https://$harbor_ip/api/v2.0/projects/$projects_name/repositories/$image_name/artifacts/$digest_list/tags/|grep "\[\]" > /dev/null

        if [ $? == 0 ]
             #检测镜像库无其他镜像tags，删除镜像库的sha256
            then
                curl -s -k -u $harbor_user:$harbor_passwd -X DELETE https://$harbor_ip/api/v2.0/projects/$projects_name/repositories/$image_name/artifacts/$digest_list
                wait
                curl -s -k -u $harbor_user:$harbor_passwd -X DELETE https://$harbor_ip/api/v2.0/projects/$projects_name/repositories/$image_name/
                echo -e "\033[36;4m 已将"$projects_name/$image_name"下的"$digest_list" 删除!\033[0m"
            else
                echo "该"$projects_name/$image_name"下的"$digest_list"还存在其他tga,不进行删除操作!"
        fi

    done
done
```

执行脚本效果如下:

```sh
[root@master deleharbor]# ./del-harbor-images.sh
已将calico/node:v3.22.0 镜像删除!
已将calico/node下的sha256:d85cd54bb27f1baa020725fc42bf5aea62e7608a58f0cf41ddb74db5b83f5935删除
已将calico/pod2daemon-flexvol:v3.22.0 镜像删除!
已将calico/pod2daemon-flexvol下的sha256:f911b3e81a9e123a9e1da90f5e1e7c63fb5bd05733267ce065b5f2b6c1f476ab删除
已将calico/cni:v3.22.0 镜像删除!
已将calico/cni下的sha256:b07b4a84d81d409963fce149f2d8a6e0a635b33601872c72efab07dd6fb0409a删除
已将calico/kube-controllers:v3.22.0 镜像删除!
已将calico/kube-controllers下的sha256:c7b7c06e9c6388bd12e59256a1d98fa79179dbb3851aca69fbf42d2cf55bcd42删除
.................................
```



###
